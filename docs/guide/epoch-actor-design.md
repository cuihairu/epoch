# Epoch Actor Runtime 设计文档

### 一、项目定位

**项目名称**: Epoch

**定位**: 基于 Aeron 的高性能 Actor / Channel Runtime，面向游戏和金融场景，强调确定性、可复现、低延迟抖动和高可推理性。

**设计哲学**:
- 时间为第一公民 (Epoch-driven)
- Actor 状态封闭、顺序执行
- Channel 提供确定性消息传递
- ECS（Entity-Component-System）用于 CPU 热路径优化

---

### 二、核心概念

#### 1. Epoch
- 定义: 一段明确的逻辑时间区间
- 作用:
  - 消息按 Epoch 分类
  - 确保 Actor 在 Epoch 内顺序执行
  - 跨 Epoch 明确可见性
- 优点:
  - 可重放、回滚
  - 降低延迟尾部抖动

#### 2. Actor
- 定义: 在固定线程上运行、在一个 Epoch 内顺序处理 inbox 消息的执行单元
- 核心约束:
  1. 状态只在所属线程访问
  2. Epoch 内输入封闭
  3. 无同步等待
  4. 状态只在 Epoch 边界对外可见
- ActorId:
  - 默认用 64-bit 数值标识，`sourceId == actorId`
  - 规则可配置：通过 `ActorIdCodec` 定义 encode/decode
  - 默认布局：`region | server | processType | processIndex | actorIndex`

#### 3. Channel
- 提供消息传递接口
- 消息在到达时只入队，不立即触发执行
- 支持不同类型:
  - MPSC / SPSC / Broadcast / LatestValue
- 配合 Epoch 确保顺序与确定性

#### 4. ECS (Entity-Component-System)
- 管理 Actor 内部或世界状态的批量数据结构
- 数据布局优化 CPU cache 使用
- 提供低延迟、高吞吐的状态更新
- 与 Actor 协作:
  - Actor 管边界、通信、生命周期
  - ECS 管数据、性能、批处理

---

### 三、传输层与多语言边界

- 传输层与运行时解耦：定义统一 Transport 接口，上层只依赖消息协议与语义
- 协议层是跨语言唯一事实来源（epoch/排序/回放/迟到策略）
- 多语言实现策略:
  - 各语言独立实现 Transport 层，遵循同一协议与语义
  - 可复用 Aeron 或自研 UDP 传输，但不依赖 C/C++ 绑定
  - 语义一致性通过协议规范与回放测试向量保证
- 一致性验证:
  - 复用统一测试向量与 stateHash 规则
- 关键边界字段（最小集合）:
  - epoch、channelId、sourceId、sourceSeq、schemaId、payload

---

### 四、调度模型对比

| 特性 | Akka / Erlang | Epoch Actor |
|---|---|---|
| 调度触发 | 消息到达即调度 | Tick / Epoch 驱动，消息先入队 |
| 线程模型 | 共享线程池 | 固定线程映射，每个 Actor 对应固定线程 |
| 抢占 | 有，线程可被抢占 | 无抢占，协作式调度 |
| 执行顺序 | 不确定，依赖线程抢占 | 确定，按 Epoch 顺序 |
| 延迟抖动 | 高 | 极低，可控 |
| 可重放 | ❌ | ✅ |
| 游戏适用性 | ⚠️ | ✅ |
| 金融适用性 | ⚠️ | ✅ |

#### 调度流程示意 (Epoch)
```
Epoch N:
  for actor in assignedActors:
    actor.pollInbox()
    actor.applyECSUpdates()
    actor.emitMessages()
```
> 固定线程 + Tick 驱动 + 顺序处理 = 可预测延迟和确定性

---

### 五、和其他模型对比

#### 1. Akka / Erlang Actor
- 优势:
  - 高吞吐
  - 弹性伸缩
  - 通用性强
- 劣势:
  - 无时间边界概念
  - 顺序不可预测
  - 消息洪峰易导致延迟抖动

#### 2. Orleans / 虚拟 Actor
- 优势:
  - 云原生，自动激活/失活
  - 状态持久化
- 劣势:
  - 不适合低延迟、实时要求
  - 不保证执行顺序

#### 3. LMAX Disruptor
- 优势:
  - 极低延迟队列
  - Cache-friendly
- 劣势:
  - 不封装 Actor 语义
  - 不处理状态生命周期

#### 4. ECS
- 优势:
  - 数据连续存储，提高 CPU cache 命中率
  - 批处理降低分支预测失败
  - 对大量对象/实体更新延迟低
- 劣势:
  - 只管数据，不管并发或通信

#### 5. Epoch Actor 组合优势
- 时间边界驱动，顺序可控
- 固定线程，减少 cache 抖动
- 可重放、可审计，降低调试复杂度
- 与 ECS 协作，提升 CPU 层性能
- 高适配性：适合游戏帧同步和金融撮合引擎

---

### 六、设计取舍总结

| 设计选择 | 原因 | 对比 Akka 优势 |
|---|---|---|
| Tick / Epoch 驱动 | 消息洪峰可控、顺序确定 | Akka 消息到达即调度导致延迟不可控 |
| 固定线程 | Cache locality + 确定性 | Akka 线程池切换，顺序不可预测 |
| 无抢占 | Actor 不被中断，容易调试 | Akka 抢占导致状态不可控 |
| 与 ECS 协作 | 数据批处理 + CPU 优化 | Akka 无本地批处理概念 |
| Channel 延迟可控 | 入队即缓存，按 Epoch 消费 | Akka 立即执行，不可控 |

---

### 七、工程应用场景

| 场景 | 为什么适合 Epoch |
|---|---|
| 游戏服务器帧同步 | Tick 驱动，消息顺序稳定，回放可复现 |
| 游戏实体管理 | Actor 管通信，ECS 管批处理，CPU cache 最优 |
| 金融撮合引擎 | 确定性成交顺序，低延迟抖动，易审计 |
| 高频事件处理 | 固定线程 + 协作式调度，延迟尾部可控 |

---

### 八、适用边界（场景明确化）

#### 1. 适合的场景
- **单分区/单写权威逻辑（默认 A 模式）**：
  - 每个 shard / room / market 只有一个权威执行点
  - 目标：低抖动 + 可回放 + 可审计
- **需要强确定性的实时对抗游戏**：
  - MOBA、竞技射击、格斗/动作对战、体育对战
  - P99/P999 延迟直接影响手感
- **帧同步/锁步类游戏**：
  - RTS、战棋、帧同步手游
  - 输入收集 + 确定性排序 + Tick 广播
- **金融顺序状态机（可选 B 模式）**：
  - 撮合引擎、订单状态机、风控流水线
  - B 模式用于主备一致重放与审计

#### 2. 适合的子场景（局部使用）
- **大型 MMO / 开放世界**：
  - 更适合用在战斗副本、竞技场、局部区域 shard
  - 不建议用单一全局 Tick 覆盖整个大世界

#### 3. 不适合的场景
- **通用分布式 Actor / 微服务平台**：
  - 强弹性伸缩、频繁迁移、强事务型工作流
- **跨分区全局强序**：
  - 需要全系统单一序列或强一致事务
- **强依赖外部非确定性**：
  - 大量阻塞 IO、DB 查询顺序、第三方回包决定逻辑
- **多语言等价权威节点**：
  - Node/Python/Go 作为权威执行节点会引入不可控抖动

#### 4. 判定准则
- 能否建模为“单分区顺序状态机 + 记录输入流 + 明确迟到/追赶策略”？
  - 能 ⇒ 适合
  - 不能 ⇒ 不适合

---

### 九、总结

Epoch Actor Runtime 的设计核心：

1. **时间驱动**，非消息驱动  
2. **固定线程 + 协作式调度**，无抢占  
3. **Actor 封闭状态 + Channel 确定性消息传递**  
4. **结合 ECS 数据布局优化 CPU 性能**  
5. **面向游戏和金融的确定性、低抖动需求**  

> 相比通用 Actor 系统（Akka / Erlang / Orleans），Epoch 的优势在于**可预测性、延迟稳定性、顺序确定性和调试复现能力**，这是游戏和金融系统的硬性需求。

---

*文档结束*
